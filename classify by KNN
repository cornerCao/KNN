import numpy as np

#输出所有文件内容的matrix和类别的vector
def readFile(filename,len):
    file1=open(filename,'r')
    returnMat=np.zeros((len,8))
    labelList=[]
    index=0
    for line in file1:
        if index>=(len-1):
            break
        filePath=line.strip()
        file=open("data/"+filePath,'r')
        for line2 in file:
            content=(line2.strip('\n').split(' '))
            for i in content:
                if i==""or i=='line':
                    content.remove(i)
            for i in content:
                if i=='':
                    content.remove(i)
            returnMat[index,:]=content[0:8]
            labelList.append(content[0])
            index+=1
        file.close()
    #print(index)
    file1.close()
    return returnMat,labelList

def calculCount(returnMat):
    res={}
    for row in returnMat:
        if row[0] in res:
            res[row[0]]+=1
        else:
            res[row[0]]=1
    return res
#计算出A的中心 发现A中心与其他类别的距离并不远 说明用KNN算法效果不会好
def calculCenterDist(fileMat,categCount):
    center_A=np.zeros((1,6))
    i=0
    for row in fileMat:
        if row[0]==1.0:
            center_A+=row[2:8]
            i+=1
        else:
            break
    center_A_r=center_A/598
    CenterDist={}
    for i in range(0,11):
        CenterDist[float(i)]=0.0
    t=0
    for row in fileMat:
        distVect=center_A-row[2:8]
        CenterDist[row[0]]+=distVect
    for i in range(0,11):
        CenterDist[float(i)]=CenterDist[float(i)]/categCount[float(i)]
    return CenterDist

#KNN进行分类,input是输入的向量,dataset是数据集,k为最近邻居个数,返回k个邻居和分类名
#这里计算的是欧氏距离
def classify(input,dataset,labels,k):
    datasetSize=dataset.shape
    #print(datasetSize)
    DIST=[]
    index=0
    Len=len(labels)
    #print(datasetSize)
    for row in dataset:
       # print(index)
        tmp=input-row
        tmp2=tmp*tmp
        dist=0
        for num in tmp2:
            dist+=num
        if index>=Len:
           # print("wuwuwu")
           # print(index)
           # print(Len)
            break
        elem=(dist,index,dataset[index:index+1,:],labels[index]) #elem由距离dist，标号index，数据向量，类别组成
        DIST.append(elem)
        index+=1
    DIST.sort(key=lambda d:d[0]) #按照dist排序 得到最近的k个邻居
    KNearNeighbour=np.array(DIST[0][2])
    labelCount={}
    labelCount[DIST[0][3]]=1
    for i in range(1,k):
        tmp=np.vstack((KNearNeighbour,DIST[i][2])) #合并邻居集
        KNearNeighbour=tmp
        if DIST[i][3] in labelCount: #统计各个类别的出现频率
            labelCount[DIST[i][3]]+=1
        else:
            labelCount[DIST[i][3]]=1
    labelSort=sorted(labelCount.items(),key=lambda d:d[1]) #统计出出现次数最多的类别
    label=labelSort[-1]
    #print(labelSort)
    return label
#用于测试算法，输出错误率和错误个数
def testKNN(testfileMat,testLabel,fileMat,labels,totalnum):
    index=0
    wrongnum=0
    #print(testfileMat.shape)
    for row in testfileMat:
        label=classify(row,fileMat,labels,100)
        resLabel=int(label[0])
        if int(testLabel[index])!=resLabel:
            wrongnum+=1
            print("true is ",testLabel[index]," and res is ",resLabel)
    wrongrate=wrongnum/totalnum
    return wrongnum,wrongrate

fileMat,labels=readFile("data/learn.list",5108)
testfileMat,testLabel=readFile("data/test.list",5000)
#print(len(labels))
#print(len(testLabel))
wrongnum,wrongrate=testKNN(testfileMat,testLabel,fileMat,labels,5000)
print(wrongnum)
print(wrongrate)
